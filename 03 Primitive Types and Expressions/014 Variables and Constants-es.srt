1
00:00:02,240 --> 00:00:07,850
Bien, comenzaremos nuestro viaje aprendiendo sobre variables y constantes.

2
00:00:07,860 --> 00:00:13,950
Comencemos por dos definiciones: una variable es un nombre que le damos a una ubicacin de almacenamiento en la memoria

3
00:00:13,950 --> 00:00:20,400
donde podemos almacenar un valor y puede estar en cualquier valor inmutable que sea un valor que conocemos en tiempo de

4
00:00:20,400 --> 00:00:24,560
compilacin y ese valor no puede cambiar a travs del vida de la aplicacin.

5
00:00:24,960 --> 00:00:26,550
Por qu usamos Konstanz?

6
00:00:26,580 --> 00:00:30,000
El motivo es crear seguridad en nuestra aplicacin.

7
00:00:30,000 --> 00:00:35,440
Imagine que est creando una aplicacin que implica clculos matemticos alrededor de crculos.

8
00:00:35,880 --> 00:00:42,450
Tenemos este nmero llamado P que es tres puntos 1 4 y lo usamos para calcular el rea de un crculo.

9
00:00:43,500 --> 00:00:45,960
Ese nmero siempre debe ser el mismo.

10
00:00:45,960 --> 00:00:49,230
No queremos cambiar eso accidentalmente en nuestro programa.

11
00:00:49,230 --> 00:00:54,270
Si accidentalmente cambiamos, todo va a explotar en trminos de los resultados que produce el programa.

12
00:00:55,500 --> 00:00:58,120
Entonces declaramos ese nmero como una constante.

13
00:00:58,860 --> 00:01:05,370
Y de esta manera creamos seguridad en nuestra aplicacin en C-sharp para declarar una variable.

14
00:01:05,370 --> 00:01:14,880
Comenzamos con un tipo seguido de un identificador y finalmente un punto y coma aqu y representa un nmero entero que es un nmero entre menos

15
00:01:14,880 --> 00:01:21,210
de 2 mil millones y ms de 2 mil millones ms adelante. En este video, le mostramos

16
00:01:21,210 --> 00:01:23,460
todos los tipos primitivos que necesita saber.

17
00:01:23,460 --> 00:01:29,880
Adems, no es que C-Sharp es un lenguaje sensible a las maysculas y minsculas, lo que significa que en este caso estos dos

18
00:01:29,880 --> 00:01:30,690
identificadores son diferentes.

19
00:01:30,690 --> 00:01:38,060
Uno tiene el caso Laura y el otro tiene maysculas y cuando se declara una variable podemos asignarle un valor de

20
00:01:38,060 --> 00:01:40,560
manera opcional como lo que ve aqu.

21
00:01:40,650 --> 00:01:45,900
No es necesario, pero hay una cosa que debe saber sobre las variables y es que no

22
00:01:45,900 --> 00:01:48,750
puede usar una variable a menos que la inicialice.

23
00:01:48,750 --> 00:01:55,020
Entonces, digamos que si declaro este nmero aqu y decido mostrarlo en la consola, mi aplicacin no

24
00:01:55,020 --> 00:01:56,550
se convertir en parte.

25
00:01:56,730 --> 00:02:00,700
Debo asignarle un valor antes de que pueda usarlo antes de poder leerlo.

26
00:02:00,750 --> 00:02:06,930
Le mostrar que ms adelante cuando saltemos a la codificacin para declarar Konstam comenzamos con la palabra clave Konst.

27
00:02:07,500 --> 00:02:10,800
Luego tenemos el tipo de datos y un identificador.

28
00:02:10,800 --> 00:02:13,770
Y aqu tenemos que inicializarlo con algn valor.

29
00:02:13,770 --> 00:02:17,620
No podemos definir una constante sin establecer su valor.

30
00:02:18,870 --> 00:02:21,750
Hay algunas cosas que debe saber sobre los identificadores.

31
00:02:21,750 --> 00:02:24,940
El primero es que un identificador no puede comenzar con un nmero.

32
00:02:25,140 --> 00:02:28,030
Entonces no puedes tener un identificador como el que ves aqu.

33
00:02:28,110 --> 00:02:31,770
En su lugar, debe reemplazar uno con la palabra uno.

34
00:02:33,090 --> 00:02:39,360
Adems, un identificador no puede incluir espacios en blanco, por lo que no puede tener un identificador como el primer nombre de espacio.

35
00:02:39,810 --> 00:02:47,130
Tiene que ser una palabra y el identificador no puede ser una palabra reservada como la que viste antes.

36
00:02:47,130 --> 00:02:52,950
Si est desesperado por usar una palabra que coincidentemente choca con una de las palabras clave

37
00:02:52,950 --> 00:02:55,680
C-sharp, puede hacer eso con el signo at.

38
00:02:55,830 --> 00:03:00,180
Y finalmente, como recomendacin, siempre use nombres significativos.

39
00:03:00,180 --> 00:03:04,670
Por ejemplo, evite un nombre como F y en su lugar utilice el nombre.

40
00:03:04,680 --> 00:03:09,400
De esta forma, su cdigo ser ms legible, ms fcil de mantener y

41
00:03:09,400 --> 00:03:13,730
ms limpio, y todos lo entendern en trminos de nomenclatura de convenciones.

42
00:03:13,740 --> 00:03:19,870
Aqu hay tres convenciones de nombres populares que han existido en la familia de lenguaje C.

43
00:03:19,890 --> 00:03:27,810
Tenemos caso de camello, caso Pasko y notacin hngara con estuche de camello, como ven, me he puesto en negrita aqu.

44
00:03:28,140 --> 00:03:34,110
La primera letra de la primera palabra es Laura y la primera letra de cada palabra despus

45
00:03:34,110 --> 00:03:41,610
de que tiene que ser mayscula con el caso Pasko. La primera letra de cada palabra debe estar en mayscula, con la

46
00:03:41,610 --> 00:03:46,710
notacin hngara como prefijo el nombre de una variable con los datos. escribe que usa.

47
00:03:46,710 --> 00:03:49,720
Entonces aqu SDR representa una cadena.

48
00:03:50,200 --> 00:03:57,030
La notacin de Angelia no se usa en C Sharp y he notado que los programadores que vienen de C o C ++ pueden

49
00:03:57,300 --> 00:03:58,560
utilizarla en su cdigo.

50
00:03:58,950 --> 00:04:04,140
Si usted es uno de ellos, le recomiendo que no use la notacin hngara porque los desarrolladores de C-Sharp no estn

51
00:04:04,140 --> 00:04:07,730
acostumbrados a eso y no les gusta ver la notacin hngara en el cdigo.

52
00:04:07,770 --> 00:04:10,420
Hace que tu cdigo se vea un poco feo.

53
00:04:10,470 --> 00:04:12,570
Entonces en C-sharp para nombrar sus variables locales.

54
00:04:12,600 --> 00:04:14,230
Usa una caja de camello.

55
00:04:14,230 --> 00:04:20,010
Entonces, como ven aqu, la primera letra de la primera palabra es minscula y si tenamos ms palabras

56
00:04:20,010 --> 00:04:27,300
aqu en el identificador, la primera letra de cada palabra tena que estar en mayscula para que las constantes usen el caso Pascal.

57
00:04:27,300 --> 00:04:33,210
As que aqu ves que tengo una constante aqu entero constante y la primera letra de cada palabra es en mayscula.

58
00:04:34,440 --> 00:04:38,980
Aqu est la lista de los tipos primitivos ms comnmente utilizados en C-sharp.

59
00:04:39,000 --> 00:04:44,250
De hecho, la lista real es un poco ms grande que esto, pero deliberadamente decid no incluir

60
00:04:44,250 --> 00:04:47,050
esos tipos de datos porque casi nunca se usan.

61
00:04:47,070 --> 00:04:51,150
De hecho, estn ah para la interoperabilidad con otros idiomas.

62
00:04:51,210 --> 00:04:54,710
Personalmente, en los ltimos 12 aos he estado codificando en C-sharp.

63
00:04:54,810 --> 00:04:56,160
Casi nunca los he usado.

64
00:04:56,280 --> 00:04:57,500
De hecho, nunca.

65
00:04:57,630 --> 00:05:02,500
As que decid no confundirlo con demasiados detalles que no necesita en la prxima diapositiva.

66
00:05:02,520 --> 00:05:06,210
Tengo un enlace aqu en caso de que quiera aprender sobre los otros tipos primitivos.

67
00:05:06,270 --> 00:05:08,460
As que echemos un vistazo a la tabla aqu.

68
00:05:08,460 --> 00:05:12,210
Por otro lado, he dividido estos tipos de datos en cuatro categoras.

69
00:05:12,610 --> 00:05:17,460
Nmeros de nmeros reales, nmeros reales y booleanos.

70
00:05:17,460 --> 00:05:21,640
Esta columna muestra los tipos de datos C-sharp y estas son palabras clave de C-Sharp.

71
00:05:22,020 --> 00:05:25,240
Tenga en cuenta que las palabras de Shoki son siempre ms bajas.

72
00:05:25,350 --> 00:05:30,840
Cada una de estas palabras clave de C-Sharp o C-Sharp se asigna a un tipo de marco de dot

73
00:05:30,840 --> 00:05:36,290
net que se muestra en esta columna, por lo que estos tipos son parte del marco de dot net.

74
00:05:36,600 --> 00:05:42,150
Y cuando compile su aplicacin, el compilador traducira internamente la palabra clave

75
00:05:42,150 --> 00:05:46,370
C-sharp que utiliza a su equivalente de ese tipo.

76
00:05:46,410 --> 00:05:50,540
La tercera columna aqu muestra la cantidad de bytes que utiliza cada tipo de datos.

77
00:05:50,600 --> 00:05:55,110
He enumerado los tipos de datos desde el ms pequeo hasta el ms grande en cada categora.

78
00:05:55,290 --> 00:05:58,470
Entonces en la categora de nmero integral como ves, byte es el ms pequeo.

79
00:05:58,470 --> 00:06:05,610
Solo se necesita un byte, mientras que el ms grande y se necesitan ocho bytes, cuantos ms bytes tengamos, ms capacidad

80
00:06:05,610 --> 00:06:06,690
de almacenamiento tendremos.

81
00:06:06,870 --> 00:06:09,120
Y podemos almacenar en grandes cantidades.

82
00:06:09,300 --> 00:06:15,000
En realidad, no tiene que memorizar el rango de cada tipo de datos, pero recuerde que el byte puede

83
00:06:15,000 --> 00:06:17,180
almacenar un valor entre 0 y 255.

84
00:06:17,370 --> 00:06:24,210
Corto puede almacenar un valor entre menos treinta y dos mil dos ms treinta y dos mil entero puede almacenar un valor

85
00:06:24,210 --> 00:06:30,120
de entre menos dos mil millones dos ms dos mil millones y largo es an mayor que en trminos

86
00:06:30,120 --> 00:06:30,840
de nmeros reales.

87
00:06:30,840 --> 00:06:32,460
Tenemos tres tipos de datos.

88
00:06:32,460 --> 00:06:39,160
Flote los mapas flotantes dobles y decimales al nico tipo en ese marco y toma cuatro bytes.

89
00:06:39,360 --> 00:06:42,320
Y como puede ver, puede almacenar un nmero muy grande.

90
00:06:42,480 --> 00:06:48,450
El doble es el doble de grande, por lo que usa 8 bytes y el decimal usa 16 bytes.

91
00:06:48,500 --> 00:06:52,260
Mientras ms precisin necesite, mayor ser el tipo de datos que use.

92
00:06:52,350 --> 00:06:57,360
Tambin tenemos un personaje que est representado por la palabra clave Charke y tiene dos bytes.

93
00:06:57,690 --> 00:07:00,190
Entonces, los caracteres en C-sharp son Unicode.

94
00:07:00,450 --> 00:07:05,770
Y finalmente tenemos bool que representa booleano que puede ser verdadero o falso.

95
00:07:06,060 --> 00:07:10,500
En caso de que desee obtener ms informacin sobre los otros tipos de datos que le dije, en realidad no los usa.

96
00:07:10,560 --> 00:07:15,740
Simplemente puede ir a Google y buscar tipos incorporados de C-Sharp y la primera pgina

97
00:07:15,750 --> 00:07:20,640
es el MSDE y la pgina que enumera todos los tipos primitivos en SUCIA.

98
00:07:20,760 --> 00:07:25,230
La mayora de estos tipos de datos son bastante sencillos, pero hay algo complicado sobre los nmeros reales en

99
00:07:26,060 --> 00:07:26,570
esta tabla.

100
00:07:26,580 --> 00:07:29,580
He enumerado los tipos de datos que tenemos para nmeros reales.

101
00:07:29,640 --> 00:07:31,470
Carga doble y decimal.

102
00:07:31,740 --> 00:07:37,690
He resaltado doble porque ese es el tipo de datos predeterminado utilizado por el compilador C-Sharp.

103
00:07:37,830 --> 00:07:39,450
Cuando ests usando nmeros reales.

104
00:07:39,960 --> 00:07:46,650
Entonces, si quiere declarar un flotante, debe decirle explcitamente al compilador que trate el nmero que tiene

105
00:07:46,920 --> 00:07:47,760
como float.

106
00:07:47,760 --> 00:07:49,010
Aqu hay un ejemplo.

107
00:07:49,020 --> 00:07:50,530
He declarado una carroza.

108
00:07:50,550 --> 00:07:53,350
Llmalo nmero asignalo un punto a.

109
00:07:53,490 --> 00:08:00,000
Aqu tengo el sufijo f y eso es decirle al compilador que trate este nmero como un flotador.

110
00:08:00,060 --> 00:08:07,080
Si no tuviera esta F aqu, el compilador pensara 1. 2 es un doble porque el doble es el tipo de datos

111
00:08:07,080 --> 00:08:08,580
predeterminado para los nmeros reales.

112
00:08:08,680 --> 00:08:13,950
Y, por supuesto, no puedo asignar un nmero doble en un flotador para que el programa no cumpla.

113
00:08:14,490 --> 00:08:15,980
Lo mismo se aplica a los decimales.

114
00:08:16,170 --> 00:08:23,050
Por lo tanto, si desea declarar un decimal, debe agregar el sufijo M al final del nmero en el contenedor.

115
00:08:23,120 --> 00:08:28,950
Tambin tenemos algunos otros tipos que no se consideran tipos primitivos y hay una matriz de

116
00:08:29,010 --> 00:08:30,250
cadenas ino y clase.

117
00:08:30,270 --> 00:08:32,720
Aprender ms sobre ellos a lo largo de este curso.

118
00:08:33,180 --> 00:08:35,690
OK, eso es todo por esta conferencia en la prxima conferencia.

119
00:08:35,700 --> 00:08:38,570
Vamos a hablar sobre el concepto de desbordamiento.

120
00:08:38,610 --> 00:08:40,640
Espero que hayan disfrutado esta conferencia y gracias por mirar

