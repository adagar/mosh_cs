1
00:00:01,140 --> 00:00:09,060
OK let's start by declaring a variable of type byte and call it number.

2
00:00:09,060 --> 00:00:11,160
Now we want to display it on the console.

3
00:00:11,160 --> 00:00:19,610
So as you remember from The Last Lecture we type console Daut writes line unput the variable here.

4
00:00:19,620 --> 00:00:25,200
Note that as I was typing console dot WriteLine my resharper plug in are magically added this using

5
00:00:25,200 --> 00:00:32,130
statement on the top system is a namespace and Konsole is a class that is defined in the System namespace

6
00:00:32,130 --> 00:00:32,760
.

7
00:00:32,790 --> 00:00:37,650
So in order to use the console class we need that declaration here on the top.

8
00:00:37,650 --> 00:00:45,000
If you're not using resharpen you have to go here and manually type using System semicolon.

9
00:00:45,120 --> 00:00:47,430
OK now take a look at this number here.

10
00:00:47,520 --> 00:00:49,160
It has a red underline.

11
00:00:49,500 --> 00:00:55,380
And if we put the mouse cursor here it says local variable number might not be initialized before accessing

12
00:00:55,380 --> 00:00:56,730
.

13
00:00:56,730 --> 00:01:02,280
If you remember from the slides I told you in C-sharp before you can access a variable you need to set

14
00:01:02,280 --> 00:01:04,160
it in it to initialize it.

15
00:01:04,590 --> 00:01:09,210
And that's the reason here we have the red underline we cannot display the number on the console before

16
00:01:09,210 --> 00:01:10,640
initializing that.

17
00:01:10,650 --> 00:01:15,810
So if I try to compile the application we're going to get an error to compile an application you press

18
00:01:15,810 --> 00:01:19,530
control shift and B.

19
00:01:19,880 --> 00:01:24,600
And here's the aerialist use of unassigned local variable number.

20
00:01:24,990 --> 00:01:30,630
We can solve this problem by initialising number like setting it to 2 for example.

21
00:01:30,630 --> 00:01:33,740
And you see the red underline is gone.

22
00:01:34,390 --> 00:01:35,340
We can compile again.

23
00:01:35,340 --> 00:01:38,300
Control shift B will succeed.

24
00:01:38,310 --> 00:01:40,040
Take a look here.

25
00:01:40,160 --> 00:01:40,710
OK.

26
00:01:40,830 --> 00:01:46,040
Now we can run the application by press and control and F 5.

27
00:01:46,950 --> 00:01:47,300
OK.

28
00:01:47,310 --> 00:01:50,550
So we got two on the console.

29
00:01:50,550 --> 00:01:58,620
Now let us extend this example and declare a few more variables can define an integer int count equals

30
00:01:58,620 --> 00:02:02,760
10 and a float float.

31
00:02:02,820 --> 00:02:08,520
So a total price equals twenty ninety five dollars.

32
00:02:08,520 --> 00:02:10,670
Now note this red underline here.

33
00:02:11,280 --> 00:02:12,750
Let's find out what's happening here.

34
00:02:12,750 --> 00:02:14,910
So I put the mouse cursor here.

35
00:02:15,810 --> 00:02:17,260
It says cannot convert.

36
00:02:17,290 --> 00:02:20,580
Source type double to target type float.

37
00:02:20,670 --> 00:02:26,640
If you remember from the slides I told you by default the seashore compiler traits real numbers like

38
00:02:26,640 --> 00:02:31,610
this one here as double where as we are declaring a float.

39
00:02:31,680 --> 00:02:37,980
So here we need to explicitly tell the compiler to treat this real number as a float and we can do that

40
00:02:38,010 --> 00:02:41,020
by appending an F at the end.

41
00:02:41,310 --> 00:02:43,870
So the error is gone.

42
00:02:43,920 --> 00:02:50,250
Mystic inner character char character A calls a.

43
00:02:51,240 --> 00:02:57,110
No that is are we enclose characters by a single quote like here.

44
00:02:57,120 --> 00:03:03,510
We can also declare a string string is not one of the primitive types and I have covered it in a separate

45
00:03:03,510 --> 00:03:04,850
lecture in this course.

46
00:03:04,860 --> 00:03:09,870
But for now let me show you how to declare a string which just type string.

47
00:03:10,200 --> 00:03:19,850
Give it a name first name a cause Marsh know that with strings being close them in double code.

48
00:03:19,950 --> 00:03:23,890
So that's one of the differences between strings and characters.

49
00:03:24,720 --> 00:03:27,930
And finally let's declare a bull.

50
00:03:28,290 --> 00:03:31,140
Bull is working a course.

51
00:03:31,170 --> 00:03:32,030
True.

52
00:03:32,670 --> 00:03:39,770
So with boules we can either set them to True or false both true and false are Keyworth as you can see

53
00:03:39,780 --> 00:03:43,740
they're indicated by the blue color here and they're lowercase.

54
00:03:43,740 --> 00:03:52,590
So everything you see here that is blue is a keyword like a static void string class namespace and all

55
00:03:52,590 --> 00:03:59,150
these data types here nounless display these variables on the console.

56
00:03:59,190 --> 00:04:04,800
So let me show you a trick.

57
00:04:04,800 --> 00:04:06,650
Instead of writing cancel the write line.

58
00:04:06,660 --> 00:04:08,820
We can do a shortcut.

59
00:04:08,820 --> 00:04:11,130
This is what we call a code snippet.

60
00:04:11,340 --> 00:04:19,180
So we type the CW that is short for console right line and then press tab and visual studio automatically

61
00:04:19,200 --> 00:04:22,070
converts that to cancel the right line.

62
00:04:22,080 --> 00:04:26,850
There are various code snippets that help you write code faster and I will try to point them out throughout

63
00:04:26,850 --> 00:04:28,850
this course.

64
00:04:29,220 --> 00:04:31,800
So let's just play count.

65
00:04:32,580 --> 00:04:34,400
Now another one.

66
00:04:35,280 --> 00:04:36,420
Total price.

67
00:04:36,520 --> 00:04:42,120
Not that I can't just type T.L. And here's what we call intellisense is Visual Studio.

68
00:04:42,180 --> 00:04:43,920
Auto completion mechanism.

69
00:04:44,100 --> 00:04:49,770
You don't have to type the full name of a type or a variable as long as the intellisense detects that

70
00:04:50,040 --> 00:04:52,400
and is highlighted here like total price.

71
00:04:52,410 --> 00:04:55,590
You can simply press tab and there you go.

72
00:04:55,590 --> 00:04:58,850
Visual studio automatically completes that for us.

73
00:04:59,060 --> 00:05:00,960
Let's display the character.

74
00:05:01,530 --> 00:05:02,340
Same here.

75
00:05:02,370 --> 00:05:06,350
I just press tab again.

76
00:05:06,360 --> 00:05:10,730
I typed only a few characters that can press tab or enter.

77
00:05:11,730 --> 00:05:13,980
And finally is working.

78
00:05:14,060 --> 00:05:17,970
We run the application by control at 5.

79
00:05:18,870 --> 00:05:20,640
So we got all these values on the console

80
00:05:23,500 --> 00:05:26,920
OK now let me show you something else in C-sharp.

81
00:05:26,950 --> 00:05:32,010
We have a keyword called vore which makes variable declarations easier.

82
00:05:32,170 --> 00:05:38,260
For example here instead of explicitly specifying the data type for each of these here I can simply

83
00:05:38,260 --> 00:05:46,970
type var and I let the C-sharp compiler detect that data type for this variable here.

84
00:05:47,530 --> 00:05:54,910
So let me replace all of this with var.

85
00:06:00,160 --> 00:06:06,960
OK now if you hover the mouse over the word key word we can see the underlying data type.

86
00:06:07,050 --> 00:06:12,890
And in this case it is system that boolean which is the dominant type which maps to C-Sharp bool keyword

87
00:06:12,940 --> 00:06:14,360
.

88
00:06:14,700 --> 00:06:18,290
I with this one that's a string.

89
00:06:19,360 --> 00:06:27,710
And this one is a character and this one is system that single which maps to float in.

90
00:06:28,600 --> 00:06:34,860
And in the case of count it's in 32 which is integer and same for number.

91
00:06:34,870 --> 00:06:41,210
So the tricky thing here is by default C-Sharp creates integral numbers as integer.

92
00:06:41,350 --> 00:06:45,100
And when you use the VAR key word it assumes that it's an integer.

93
00:06:45,100 --> 00:06:49,960
If you really want to go for a byte then you have to explicitly say mystified as byte here but tell

94
00:06:49,960 --> 00:06:52,630
you from experience it's safe to use integer.

95
00:06:52,630 --> 00:06:58,960
In most cases in fact if you look at the classes in the Dartmouth framework in most cases integer is

96
00:06:58,960 --> 00:07:03,670
the data type used for representing integral numbers.

97
00:07:04,410 --> 00:07:06,910
OK I reverted back.

98
00:07:06,930 --> 00:07:08,570
Now I show you something else.

99
00:07:08,590 --> 00:07:10,610
So let's take a look at this one here.

100
00:07:10,690 --> 00:07:17,500
So it's a char which is a character we can put the mouse cursor here and press control and then click

101
00:07:21,970 --> 00:07:24,950
that opens the object browser window.

102
00:07:24,970 --> 00:07:30,820
Take a look here is Object Browser and it's a way to look at the various classes in your project or

103
00:07:30,820 --> 00:07:32,370
in the top that framework.

104
00:07:32,410 --> 00:07:38,060
In this case because I did a control click on the char or var keyword.

105
00:07:38,200 --> 00:07:39,940
This is what we got here.

106
00:07:39,940 --> 00:07:46,690
So char is highlighted in the ogic browser on the right side you see all the members of the char type

107
00:07:46,710 --> 00:07:47,030
.

108
00:07:47,320 --> 00:07:51,210
So these purple ones are functions or methods.

109
00:07:51,730 --> 00:07:56,810
If you scroll down here you'll see two fields here main Valeo and max value.

110
00:07:56,950 --> 00:08:04,210
We'll explore them shortly and note that here is the declaration of char char is a structure we will

111
00:08:04,210 --> 00:08:06,310
cover as structures later in this course.

112
00:08:06,490 --> 00:08:10,500
And note that it's a member of System namespace.

113
00:08:10,750 --> 00:08:18,280
You can click system and that shows the System namespace as well as all the types defined in the System

114
00:08:18,280 --> 00:08:19,340
namespace.

115
00:08:19,420 --> 00:08:23,000
So these are part of the dominant framework.

116
00:08:23,200 --> 00:08:25,550
OK let's close this for now.

117
00:08:26,560 --> 00:08:28,520
Let's explore another example.

118
00:08:28,570 --> 00:08:33,060
So I'm going to get rid of all the code here we because simply press control X on each line

119
00:08:37,780 --> 00:08:40,430
and that deletes all these lines here.

120
00:08:41,110 --> 00:08:41,740
OK let's do it.

121
00:08:41,740 --> 00:08:42,810
Cancel the write line.

122
00:08:42,850 --> 00:08:50,770
So CW tab this time I pass a string here and you specify two placeholders

123
00:08:54,240 --> 00:09:00,530
and finally supply a couple of arguments.

124
00:09:03,850 --> 00:09:05,890
OK let's see what's going on here.

125
00:09:05,920 --> 00:09:10,080
So here what we have is called a format string.

126
00:09:10,390 --> 00:09:13,870
It's a kind of string that can be used as some kind of template.

127
00:09:14,010 --> 00:09:21,640
So at runtime what we have here indicated by curly braces and zero as the argument will be replaced

128
00:09:21,910 --> 00:09:24,110
by the value we pass here.

129
00:09:24,160 --> 00:09:32,820
So 0 represents the first argument after this format string and one represents the second argument after

130
00:09:32,830 --> 00:09:36,730
this format string in this case byte the next value.

131
00:09:36,730 --> 00:09:40,770
So let's run this application.

132
00:09:41,920 --> 00:09:49,830
We got 0 and 255 and that's the range that you can store in a byte.

133
00:09:50,560 --> 00:09:52,490
We can do the same with the float.

134
00:09:52,690 --> 00:09:58,180
So CW tap a format string

135
00:10:01,120 --> 00:10:06,830
float mean value float max value.

136
00:10:07,610 --> 00:10:13,640
Run the application.

137
00:10:13,810 --> 00:10:17,170
So this is the range we can store with a float.

138
00:10:17,170 --> 00:10:20,290
It's a huge number that is displayed using the scientific notation

139
00:10:22,120 --> 00:10:24,620
.

140
00:10:25,300 --> 00:10:28,410
OK now let's take a look at constants.

141
00:10:29,050 --> 00:10:30,740
So I get rid of these two lines here.

142
00:10:30,940 --> 00:10:42,730
Control X control X we define a constant with the const keyword Konst float P three point 1 4 and we

143
00:10:42,730 --> 00:10:45,890
have to put f at the end because it's a float.

144
00:10:46,180 --> 00:10:52,780
Now because we declared p as a constant here I can change it in my program so I can go here and say

145
00:10:52,780 --> 00:10:55,550
P it cools one.

146
00:10:56,920 --> 00:11:01,150
The compiler is not happy and that's why we see that red underline here.

147
00:11:01,240 --> 00:11:07,990
If you hover the mouse here it says read only local content cannot be used as an assignment target.

148
00:11:08,140 --> 00:11:13,720
It's a little weird expression to understand but basically the intention of using constants is to have

149
00:11:13,720 --> 00:11:15,700
some kind of safety in your program.

150
00:11:15,820 --> 00:11:20,530
So if there are values that should not be changed beyond your program you defined them as constants

151
00:11:20,530 --> 00:11:21,450
.

152
00:11:22,060 --> 00:11:24,980
And this way you won't accidentally modify their values

